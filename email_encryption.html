<html>
<a href=index.html>Back to home</a>
<hr/>
<h1>Email Encryption</h1>
<p>Most businesses use email as the primary source of communication as it is simple and easy to 
  communicate or share information. Emails can contain sensitive information, in wrong hands it can 
  cause severe losses.</p>
  <h2>Digital Signature</h2>
  <p>A digital signature uses asymmetric cryptography to simulate the security properties of a 
  signature in digital form rather than in written form. A digital signature is a cryptographic 
  means of authentication. Public key cryptography uses asymmetric encryption and helps the user 
  to create a digital signature. The two types of keys in public key cryptography are the 
  private key (only the signer knows this key and uses it to create a digital signature) and the 
  public key (widely known and the relying party uses it to verify the digital signature).</p>
  <p>A hash function is an algorithm that helps a user to create and verify a digital signature.
  This algorithm creates a digital representation, also known as the message fingerprint. This 
  fingerprint has a hash value that is much smaller than the message, but one that is unique to it.
  If the attacker changes the message, the hash function will automatically produce a different 
  hash value.</p>
  <p>To verify the digital signature, one needs the hash value of the original message and the 
  encryption algorithm used to create the digital signature. Using both the public key and the new
  result, the verifier checks to see if the digital signature was created with the related private 
  key and whether the new hash value is the same as the original one. A digital signature may be 
  further protected by encrypting the signed email for confidentiality.</p>

  <h2>Secure Sockets Layer (SSL)</h2>
  <p>SSL protocol is an application layer protocol developed by Netscape for managing the 
  security of message transmission on the Internet. It is used to provide a secure authentication 
  mechanism between two communicating applications, such as a client and a server. SSL requires a 
  reliable transport protocol, such as TCP for data transmission and reception. It uses RSA 
  asymmetric (public key) encryption to encrypt data transferred over SSL connections.</p>
  <p>Any application layer protocol that is higher than SSL, such as HTTP, FTP and Telnet, can form 
  a transparant layer over SSL. SSL acts as an arbitrator between the encryption algorithm and the
  session key; it also verifies the destination server prior to the transmission and reception of 
  data. SSL encrypts the complete data of the application protocol to ensure security.</p>
  <p>SSL also offers <b>channelsecurity</b> with three basic properties:</p>
  <p><ol>
    <ul>Private channel -> all the messages are encrypted after a simple handshake is used to define 
    a secret key</ul>
    <ul>Authenticated channel -> the server endpoint of the conversation is always encrypted, whereas 
    the client endpoint is optionally authenticated</ul>
    <ul>Reliable channel -> message transfer has an integrity check</ul>
  </ol></p>
<p>SSL uses both asymmetric and symmetric authentication mechanisms. Public-key encryption verifies 
the identities of the server, the client or both. Once authentication has occurred, the client and server 
can create symmetric keys, allowing them to communicate and transfer data rapidly. An SSL session is 
responsible for carrying out the SSL handshake protocol to organize the states of the server and client, thus 
ensuring consistency of the protocol.</p>
<h2>SSL handshake protocol flow</h2>
<p>The SSL handshake protocol works on top of the SSL record layer. The processes executed in the three-way
handshake protocol are as follows:</p>
<p><ol>
  <ul>The client sends a hello message to the server, to which the server must respond with a hello message, 
  or the connection will fail due to the occurrence of a fatal error; The attributes established due to the 
  server and client hello are protocol version, session ID, cipher suite and compression method</ul>
  <ul>After the connection is established, the server sends a certificate to the client for authentication. In 
  addition, the server might send a server-key exchange message. On authentication of the server, it may ask 
  the client for the certificate (if appropriate for the cipher suite selected)</ul>
  <ul>The server sends a "hello done" message to inform the client that the handshake phase is complete and 
  waits for the client's response</ul>
  <ul>If the client receives a certificate request message, the client must respond to the message by 
  sending a certificate message or "no certificate" alert. The server sends the client key-exchange message. 
  The content of the message depends on the public-key algorithm between the server hello and the client hello.
  If the certificate sent by the client has signing ability, a digitally signed certificate verifies the message, 
  and the client transmits it</ul>
  <ul>The client transmits the changed cipher-spec message and copies the pending cipher spec into the current cipher 
  spec. The client sends a message to initiate the completion of the message under the new algorithm, keys and 
  secrets</ul>
  <ul>In response, the server replies by sending its own changed cipher-spec message, transfers the pending cipher 
  spec to the current cipher spec, and initiates the completion of the message under the new cipher spec. At this point, 
  the handshake is complete and the server starts exchanging the application-layer data</ul>
</ol></p>
  <p>The resumption of a previous session or the replication of an existing session proceeds as follows:</p>
  <p><ol>
    <ul>The client initiates the communication by sending a hello message with the session ID of the session 
    that is to be resumed</ul>
    <ul>If the server finds a match, it re-establishes the session under the specified session state with the same 
    session ID</ul>
    <ul>At this point, both the server and the client exchange the changed spec messages and proceed directly to the 
    finished messages</ul>
    <ul>After re-establishment, the server and client exchange data at the application layer</ul>
    <ul>If the session ID does not exist, the server creates a new session ID. The SSL client and server
    then carry out a complete handshake.</ul>
  </ol></p>

  <h2>Transport Layer Security TLS</h2>
  <p>TLS protocol is used to establish a secure connection between a client and a server and 
  ensure the privacy and integrity of information during transmission. It uses a symmetric key 
  for bulk encryption, asymmetric key for authentication and key exchange and message authentication 
  codes for message integrity. It uses the RSA algorithm with strengths of 1024 and 2048 bits.
  Using TLS, one can reduce security risks such as message tampering, message forgery and message 
  interception. An advantage of TLS is that it is independent of the application protocol. Higher-level 
  protocols can lie on top of TLS transparancy.</p>

  <p>TLS consists of two layers: TLS Record Protocol and TLS Handshake Protocol.</p>
  <h2>TLS Record Protocol</h2>
  <p>TLS Record Protocol is a layered protocol; it provides secured connections with an 
    encryption method such as DES; it secures application data using the keys generated 
    during the handshake and verifies its integrity and origin. The TLS Record Protocol 
    provides connection security with two basic properties:</p>
  <p><ol>
    <ul>The connection is private -> uses symmetric cryptography for data encryption (e.g. DES). The protocol 
    generates unique keys for symmetric encryption for each connection, depending on a secret negotiated by 
    another protocol (such as the TLS Handshake Protocol). One can use the TLS Record Protocol without encryption.</ul>
    <ul>The connection is reliable -> it provides a message integrity check at the time of message transport using a 
    keyed MAC. Secure hash functions (e.g. SHA, MD5) help to perform MAC computations</ul>
  </ol></p>
<p>The TLS Record Protocol does the following:</p>
<p><ol>
  <ul>Fragments outgoing data into manageable blocks and reassembles incoming data</ul>
  <ul>Optionally compresses outgoing data and decompresses incoming data</ul>
  <ul>Applies MAC to the outgoing data and uses MAC to verify the incoming data</ul>
  <ul>Encrypts outgoing data and decrypts incoming data</ul>
</ol></p>
  <p>The TLS Record Protocol sends the outgoing encrypted data to the TCP layer for transport.</p>
  <h2>TLS Handshake Protocol</h2>
  <p>The TLS Handshake Protocol allows the client and server to authenticate each other and select an 
  encryption algorithm and cryptographic keys prior to data exchange by the application protocol.</p>
  <p>It provides connection security with three basic properties:</p>
  <p><ol>
    <ul>The peer's identity cna be authenticated using asymmetric cryptography. This can be
    made optional but is mostly required for at least one of the peers</ul>
    <ul>The negotiation of a shared secret is secure</ul>
    <ul>The negotiation is reliabled</ul>
  </ol></p>
  <p>The TLS Handshake Protocol operates on top of the TLS Record Protocol and is responsible 
  for producing cryptographic parameters of the session state. At the start of communication, 
  the TLS client and server agree on a protocol version, select cryptographic algorithms, optionally 
  authenticate each other, and use asymmetric crytography techniques to create shared secrets.</p>

  <p>The steps involved in the TLS Handshake Protocol are as follows:</p>
  <p><ol>
    <ul>Initially, the client sends a "Client hello" message accompanied by the client's random 
    value and supported cipher suites to the server</ul>
    <ul>The server responds to the client by sending a "Server hello" message accompanied by the 
    server's random value</ul>
    <ul>The server sends its certificate to the client for authentication and may request the 
    client's certificate. The server sends the "Server hello done" message</ul>
    <ul>The client sends its certificate to the server, if requested</ul>
    <ul>The client generates a random pre-master secret and encrypts it with the server's public 
    key; then, it sends the encrypted pre-master secret to the server</ul>
    <ul>The server receives the pre-master secret. Thereafter, the client and server each create 
    the master secret and session keys based on the pre-master secret</ul>
    <ul>The client sends "Change cipher spec" to the server to indicate that it will start using 
    the new session keys for hashing and encrypting messages. The client also sends "Clientfinished"</ul>
    <ul>The server receives "Changecipher spec" from the client and switches its record layer 
    security state to symmetric encryption using the session keys. Then, the server sends 
    "Serverfinished" to the client</ul>
    <ul>Now, the client and server can exchange application data over the secure channel they have
    established, and all the messages exchanged between the client and server are encrypted using a 
    session key</ul>
  </ol></p>
  <h2>Difference between SSL and TLS</h2>
  <p><ol>
    <ul>TLS: Transport Layer Security</ul>
    <ul>SSL: Secure Socket Layer</ul>
    <ul>SSL: released 1995</ul>
    <ul>TLS: released 1999 as upgrade to SSL 3.0</ul>
    <ul>TLS succeeded SSL as the standard for secure online communications due to its 
    improved security features</ul>
  </ol></p>

  
