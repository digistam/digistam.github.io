<html>
    <meta name=”robots” content=”noindex,nofollow”/>
  <a href=index.html>Back to home</a>
<hr/>
<h1>Session Hijacking</h1>
<p>A web server sends a session identification token or key to a web client after succesful authentication. These session tokens differentiate multiple sessions that the server establishes with clients. 
  Web servers use various mechanisms to generate random tokens and controls to secure the tokens during transmission. Session hijacking is an attack in which an attacker takes over a valid Transmission Control Protocol 
  (TCP) communication between two computers. Because most types of authentication are performed only at the start of a TCP session, an attacker can gain access to a machine while a session is in progress. Attackers 
  can sniff all the traffic from established TCP sessions and perform identity theft, information theft, fraud etc.</p>
  <p>A session hijacking attack exploits a session-token generation mechanism or token security controls so that the attacker can establish an unauthorized connection with a target server. The attacker can guess 
  or steal a valid session ID, which identifies authenticated users, and use it to establish a session with the server. The web server responds to the attacker's request under the impression that it is 
  communicating with an authenticated user.</p>
  <p>Attackers can use session hijacking to launch various kinds of attacks, such as MITM and DoS attacks. In an MITM attack, an attacker places themselves between an authorized client and a server by 
  performing session hijacking to ensure that information flowing in either direction passes through them. However, the client and server believe they are directly communicating with each other. Attackers can also 
  sniff sensitive information and disrupt sessions to launch a DoS attack.</p>
  <h2>Why is Session Hijacking successful </h2>
  <p><ol>
    <ul>Absence of account lockout for invalid session IDs -> if a website does not implement account lockout an attacker can make several attempts to connect with varying session IDs embedded in a genuine URL (brute-force)</ul>
    <ul>Weak session ID generation algorithm or small session IDs -> most websites use linear algorithms to predict variables such as time or IP address for generating session IDs; by studying the sequential pattern and generating multiple requests 
    an attacker can easily narrow the search space necessary to forge a valid session ID</ul>
    <ul>Insecure handling of session IDs -> an attacker cna retrieve stored session ID information by misleading the user's browser into visiting another site</ul>
    <ul>Indefinite session timeout -> session IDs with an indefinite expiration time provides an attacker with unlimited time to guess a valid session ID (remember me - option) after capturing the user's cookie file</ul>
    <ul>Most computers using TCP / Internet Protocol (IP) are vulnerable</ul>
    <ul>Most countermeasures do not work without encryption -> easy to sniff if transport security is not set up properly during transmision of session ID cookies</ul>
  </ol></p>
<h2>Phases</h2>
    <p><ol>
        <ul><b>Tracking the Connection</b>: The attacker uses a network sniffer to track a victim and host, or uses a tool such as Nmap to scan the network for a target with a TCP sequence that is easy to predict</ul>
        <ul><b>Desynchronizing the Connection</b>: A desynchronized state occurs when a connection between the target and host has been established, or is stable with no data transmission, or when the server’s sequence number is not equal to the client’s acknowledgment number (or vice versa)</ul>
        <ul><b>Injecting the Attacker’s Packet</b>: Once the attacker has interrupted the connection between the server and target, they can either inject data into the network or actively participate as the man-in-the-middle, passing data between the target and server, while reading and injecting data at will</ul>
    </ol></p>
  <h1>Session Hijacking Process</h1>
  <p><ol>
    <ul>An attacker can hijack a genuine user's session by finding an established session and taking it over after user authentication</ul>
    <ul>After hijacking the session, the attacker can stay connected for hours without suspicion</ul>
    <ul>During this period, all traffic intended for the user's IP address goes to the attacker's system instead and the attacker can plant backdoors or gain additional access to the system</ul>
  </ol></p>
  <h2>Tracking the connection</h2>
  <p>The attacker uses a network sniffer to track a victim and host or uses a tool such as nmap to scan the network for a target with a TCP sequence that is easy to predict. After identifying a victim, 
  the attacker captures the sequence and acknowledgement numbers of the victim because TCP checks these numbers. The attacker then uses these numbers to construct packets.</p>
  <h2>Desynchronizing the connection</h2>
  <p>A desynchronized state occurs when a connection between a target and host is established, or stable with no data transmission or the server's sequence number is not equal to the client's 
  acknowledgement number, or vice versa. To desynchronize the connection between the target and host, the attacker must change the sequence number of acknowledgement number (SEQ / ACK) of the server. 
  For this purpose, the attacker sends null data to the server; consequently the server's SEQ / ACK numbers advance, while the target machine does not register the increment. For example, before desynchronization the 
  attacker monitors the session without any interference, following which they send a large amount of null data to the server. These data change the ACK number on the server without affecting anything else, thereby 
  desynchronizing the server and target.</p>
  <p>Another approach is to send a reset flag to the server to break the connection on the server side. Ideally, this occurs in the early setup stage of the connection. The attacker's goal is to break the connection 
  on the server side and create a new connection with a different sequence number.</p>
  <p>The attacker waits for a SYN / ACK packet from the server to the host. On detecting a packet, the attacker immediately sends an RST packet and a SYN packet with identical parameters, such as port number with 
  a different sequence number, to the server. The server, on receiving the RST packet, closes the connection with the target and initiates another one based on the SYN packet but with a different sequence number 
  on the same ports. After opening a new connection, the server sends a SYN / ACK packet to the target for acknowledgement. The attacker detects (but does not intercept) this packet and sends an ACK packet to the 
  server. Now, the server is in established state. The aim is to keep the target conversant and ensure that it switches to the established state on receiving the first SYN/ACK packet from the server. Consequently, 
  both the server and target are desynchronized but in established state.</p>
  <p>An attacker can also use a FIN flag, but this will make the server respond with an ACK packet, thus revealing the attack through an ACK storm. The attack is revealed because of a flaw in this method of 
  hijacking a TCP connection. While receiving an unacceptable packet, the host acknowledges it by sending the expected sequence number. This unacceptable packet generates an ACK packet, thereby creating an endless 
  loop for every data packet. The mismatch in SEQ / ACK numbers results in excess network traffic with both the server and target attempting to verify the correct sequence. Because these packets carry no data, 
  retransmission does not occur if the packet is lost. However, because TCP uses IP, the loss of a single packet ends the unwanted conversation between the server and target.</p>
  <p>An attacker can add a desynchronizing stage to the hijack sequence to deceive the target host. Without desynchronizing, the attacker injects data into the server while keeping their identity hidden by 
  spoofing an IP address. However, the attacker should ensure that the server responds to the target host as well.</p>
    <h2>Injecting the attacker's packet</h2>
    <p>Once the attacker has interrupted the connection between the server and target, they can either inject data into the network or actively participate as the MITM, passing data from the target to the server 
    and vice-versa while reading and injecting data at will.</p>
    <h1>Packet Analysis of a local session hijack</h1>
    <p>TCP is used for transmitting data by many systems that establish LAN or INTERNET connections. To establish a connection between two systems and for the succesful transmission of data, the two systems 
    should perform a three-way handshake. Session hijacking involves the exploitation of this three-way handshake method to take control over the session. Three activities:</p>
    <p><ol>
        <ul>Tracking of a session</ul>
        <ul>Desynchronization of the session</ul>
        <ul>Injection of commands during the session</ul>
    </ol></p>
    <p>By sniffing network traffic, an attacker can monitor or track a session. Desynchronization of the session is easy if the <b>next sequence number (NSN)</b> is known. A session can be hijacked by using 
    the NSN before the client uses it.</p>
    <p>Two possibilities:</p>
    <p><ol>
        <ul>Sniff the traffic, find an <b>ACK</b> packet and then determine the NSN based on the ACK -> local session hijacking</ul>
        <ul>Transmit data with guessed sequence numbers (not reliable!)</ul>
    </ol></p>
    <h1>Types of Session Hijacking</h1>
    <p><ol>
        <ul>Passive Session Hijacking -> observing with sniffers, password sniffing</ul>
        <ul>Active Session Hijacking -> MITM, guessing the sequence number before the target responds to the server</ul>
    </ol></p>
    <h1>Session Hijacking in OSI Model</h1>
    <p><ol>
        <ul>Network-Level Hijacking -> data flow across all web applications</ul>
        <ul>Application-Level Hijacking -> gaining control over HTTP user session by obtaining the session IDs</ul>
    </ol></p>
    <p>In general, both occur together, depending on the system being attacked</p>
    
    <h1>Blind Hijacking</h1>
    <p>In <b>blink hijacking</b> an attacker predicts the sequence numbers that a victim host sends to create a connection that appears to originate from the host or a blind spoof. To understand blind hijacking, 
    it is important to understand <b>sequence-number prediction</b>. All bytes in a TCP connection are numbered, beginning at a randomly chosen initial sequence number (ISN). The SYN packets consume one sequence number, 
        so actual data will begin at ISN+1. The sequence number is the byte number of the first byte of data in the TCP packet sent (also called a TCP segment). The acknowledgement number is the sequence number of 
        the next byte the receiver expects to receive. The receiver ack'ing sequence number x acknowledges receipt of all data bytes less than (but not including) byte number x. The sequence number is always valid. 
        The acknowledgement number is only valid when the ACK flag is one. The only time the ACK flag is not set, that is, the only time there is not a valid acknowledgement number in the TCP header, 
        is during the first packet of connection set-up.</p>
        <p>TCP sequence numbers, which are unique per byte in a TCP session, provide flow control and data integrity. TCP segments provide the <b>initial sequence number (ISN)</b> as a part of each segment header.
        As part of the handshake process, each participant needs to state the ISN, and bytes are numbered sequentially from that point.</p>
        <p><b>Blind session hijacking</b> relies on the attacker's ability to predict or guess sequence numbers. An attacker is unable to spoof a trusted host on a different network. The attacker is also unable to resort to 
        <b>Address Resolution Protocol (ARP) cache poisoning</b> because routers do not broadcast ARP across the internet. Because the attacker is unable to observe the replies, he must anticipate the responses from the 
        victim and prevent the host from sending a TCP/RST packet to the victim. The attacker predicts sequence numbers that the remote host expects from the victim and then hijacks the communication. This method is 
        useful when exploiting trust relationships between users and remote machines.</p>
        <p>In a spoofing attack, an attacker pretends to be another user or machine (victim) to gain access. Instead of taking over an existing active session, the attacker initiates a new session using the victim's 
        stolen credentials. IP spoofing forces the attacker to forecast the NSN. When an attacker uses blind hijacking to send a command, they cannot view the response.</p>
        <p>In the case of IP spoofing without a session hijack, guessing the sequence number is unnecessary because no currently open session exists with that IP address. In a session hijack, the traffic returns to the 
        attacker only if <b>source routing</b> is used.</p>
        <h2>Source routing</h2>
        <p>Source routing is a process that allows the sender to specify the route to be taken by an IP packet to the destination. The attacker performs source routing and then sniffs the traffic as it passes by the 
        attacker. In session spoofing, <b>captured authentication credentials</b> are used to establish a session.</p>
        <p>Session hijacking is the process of taking over an existing active session. An attacker relies on a legitimate user to make a connection and authenticate. Session hijacking is more difficult than IP 
        address spoofing. In session hijacking, an attacker would seek to insert himself into a session that a legitimate user already had set up with \\Mail. The attacker waits until the legitimate user 
        establishes a session, displace the legitimate user from the established session (using for example a DoS attack) and then pick up the session as though he was the legitimate user. Subsequently, the 
        attacker would send a scripted set of packets to \\Mail and observe the responses. The attacker needs to know the sequence number in use when he hijacked the session. To calculate the sequence number, 
        he must know the ISN and the number of packets involved in the exchange process.</p>
        <p>Succesful session hijacking is difficult without the use of known tools and is only possible when several factors are under the attacker's control.</p>
        <p>Hijacking of non-encrypted TCP communications requires the presence of non-encrypted session-oriented traffic, the ability to recognize TCP sequence numbers from which the next sequence number (NSN) 
        can be predicted, and the ability to spoof a host's MAC or IP address to receive communications that are not destined for the attacker's host. If the attacker is on the local segment, he can sniff 
        and predict the ISN+1 number and route the traffic back to him by poisoning the ARP caches on the two legitimate hosts participating in the session.</p>
    <h1>Application-Level Session Hijacking</h1>
    <p>In application-level session hijacking, an attacker steals or predicts a valid session token to gain unauthorized access to a web server or create a new unauthorized session. Usually, network-level and 
    application-level session hijacking occur together because a succesful network-level session hijack provides an attacker with ample information to perform application-level session hijacking. Application-level 
    session hijacking relies on HTTP sessions.</p>
    <h2>Techniques</h2>
    <p><ol>
        <ul>Stealing</ul>
        <ul>Guessing</ul>
        <ul>Brute forcing</ul>
    </ol></p>
    <p>A session token can be compromised in various ways:</p>
    <p><ol>
        <ul>Session sniffing</ul>
        <ul>Predictable session token</ul>
        <ul>MITM attack</ul>
        <ul>Man-in-the-browser attack</ul>
        <ul>Cross-site scripting (XSS) attack</ul>
        <ul>Cross-site request forgery attack</ul>
        <ul>Session replay attack</ul>
        <ul>Session fixation attack</ul>
        <ul>CRIME attack</ul>
        <ul>Forbidden attack</ul>
        <ul>Session donation attack</ul>
        <ul>PetitPotam hijacking</ul>
    </ol></p>

    <h2>Sniffing session IDs</h2>
    <p>An attacker uses packet sniffing tools such as Wireshark and Riverbed Packet Analyzer Plus to intercept the HTTP traffic between victim and web server. The intercepted data is used to identify valuable information 
    such as session IDs and passwords.</p>
    <h2>Predicting session token</h2>
    <p>Session predicting enables an attacker to bypass the authentication schema of an application. Usually, attackers can predict session IDs generated by weak algorithms. Attackers analyze a variable section of session IDs 
    to determine the existence of a pattern. This analysis is performed either manually or by using various cryptanalytical tools.</p>
    <p>Attackers can identify session IDs generated in the following ways:</p>
    <p><ol>
        <ul>Embedding in the URL (GET request)</ul>
        <ul>Embedding in a form as a hidden field (POST command)</ul>
        <ul>Embedding in cookies on the client's local machine</ul>
    </ol></p>

    <h2>Man-in-the-Browser / Manipulator-in-the-Middle attack</h2>
    <p>Using different techniques, attackers split a TCP connection into two: a client-to-attacker connection and an attacker-to-server connection.</p>
    <p>A man-in-the-browser / manipulator-in-the-browser attack is similar to a MITM attack. The difference is that a man-in-the-browser uses a Trojan horse to intercept and manipulates calls between a browser 
    and its security mechanisms or libraries. The Trojan can modify web pages and transaction content or insert additional transactions. The main objective is financial theft by manipulating transactions made 
    using Internet banking systems.</p>
    <p>A man-in-the-browser attack can succeed even in the presence of security mechanisms such as SSL, PKI and 2FA.</p>
    <p><ol>
        <ul>The Trojan infects the computer's software (OS or application)</ul>
        <ul>The Trojan installs malicious code (extension files) and saves it in the browser configuration</ul>
        <ul>After the user restarts the browser, the malicious code in the form of extension files is loaded</ul>
        <ul>The extension files register a handler for every visit to a webpage</ul>
        <ul>When a page is loaded, the extension matches its URL with a list of known sites targeted for attack</ul>
        <ul>The user logs in securely to the website</ul>
        <ul>The extension registers a button event handler when a specific page load is detected with a specific pattern and compares it with its targeted list</ul>
        <ul>When the user clicks on the button, the extension uses the DOM interface and extracts all the data from all form fields and modifies the values</ul>
        <ul>The browser sends the form and modifies values to the server</ul>
        <ul>The server receives the modified values but cannot distinguish between the original and modified values</ul>
        <ul>After the server performs the transaction, a receipt is generated</ul>
        <ul>Now, the browser receives the receipt for the modified transaction</ul>
        <ul>The browser displays the receipt with the original values</ul>
    </ol></p>

    <h2>Client-side Attacks</h2>
    <p>Client-side attacks target vulnerabilities in client applications that interact with a malicious server or process malicious data. An attacker can exploit an application by sending an email with 
    a malicious link or otherwise tricking a user into visiting a malicious website. Vulnerable clients-side applications include unprotected websites, Java Runtime Environment (JRE) and browsers. Browsers are the 
    major target.</p>
    <p><ol>
        <ul>Cross-site scripting (XSS) -> injecting malicious client-side scripts into web pages viewed by other users</ul>
        <ul>Malicious JavaScript codes -> capturing session tokens in the background and send them to the attacker</ul>
        <ul>Trojans -> change proxy settings in the user's browser to send all sessions through an attacker's machine</ul>
    </ol></p>

    <h2>Cross-site Request Forgery Attack (CSRF)</h2>
    <p>An attacker creates a host form, containing malicious information, and sends it to the authorized user. The user fills the form and sends it to the web server. Because the data originates from a trusted 
    user, the web server accepts the data. Unlike an XSS attack, which exploits the trust a user has for a particular website, CSRF exploits the trust that a website has on a user's browser.</p>
    <p><ol>
        <ul>The attacker hosts a web page with a form that appears legitimate; the page already contains the attacker's request</ul>
        <ul>A user, believing the form to be the original, enters a login and password</ul>
        <ul>Once the user completes the form, that page is submitted to the real site</ul>
        <ul>The real site's server accepts the form, assuming that it was sent by the user based on the authentication credentials</ul>
        <ul>In this manner, the server accepts the attacker's request</ul>
    </ol></p>

    <h2>Session Replay Attacks</h2>
    <p>The attacker captures the authentication token of a user by listening to a conversation between the user and server. Once the authentication token is captured, the attacker replays the authentication 
    request to the server with the captured authentication token to dodge the server.</p>
    <p><ol>
        <ul>The user establishes a connection with the web server</ul>
        <ul>The server asks the user for authentication information as identity proof</ul>
        <ul>The user sends authentication tokens to the server</ul>
        <ul>An attacker captures the authentication token of the user by eavesdropping on the conversation between user and server</ul>
        <ul>Once the authentication token is captured, the attacker replays the request to the server with the captured authentication token and gains unauthorized access to the server.</ul>
    </ol></p>

    <h2>Session Fixation</h2>
    <p>Web session security prevents an attacker from intercepting, brute forcing or predicting the session ID. However, it is always possible for an attacker to issue a session ID to the user's browser, 
    forcing it to use the chosen session ID. This is called a session fixation attack, because an attacker fixes the user's session ID in advance, instead of generating it randomly at the time of login.</p>
    <p>Web applications allow the user to authenticate themselves using an existing session ID. In this attack, the attacker provides a legitimate web-application session ID and lures the victim to use it.
    If the victim's browser uses that session ID, the attacker can hijack the user-validated session because the attacker is already aware of the session ID used by the victim.</p>
    <p><ol>
        <ul>Session token in the URL argument</ul>
        <ul>Session token in a hidden form field</ul>
        <ul>Session ID in a cookie</ul>
    </ol></p>
    <p>A session fixation attack has the following three phases:</p>
    <p><ol>
        <ul>Session set-up phase -> the attacker obtains a session ID</ul>
        <ul>Fixation phase -> the attacker introduces the session ID to the victim's browser</ul>
        <ul>Entrance phase -> the attacker waits for the victim to log in to the target web server and then enters the victim's session</ul>
    </ol></p>
    <p>Because the session ID is set by the attacker before the user logged in, the user can be said to have logged into the attacker's session.</p>
